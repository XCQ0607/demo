模板
----------------------------------------------------
题目:

解答：
go.c文件


main.c文件:
#include "go.c"

1.请帮我写main.c中的main函数，调用go.c中的函数并传入参数

2.通过示例1详细和我讲一下这个代码从main函数开始发的执行过程。最好使用图形化的方式帮助理解。

3.如果解决代码使用了某种算法，请向我说明并介绍它

----------------------------------------------------

2389
题目:
给你一个长度为 n 的整数数组 nums ，和一个长度为 m 的整数数组 queries 。
返回一个长度为 m 的数组 answer ，其中 answer[i] 是 nums 中 元素之和小于等于 queries[i] 的 子序列 的 最大 长度  。
子序列 是由一个数组删除某些元素（也可以不删除）但不改变剩余元素顺序得到的一个数组。

示例 1：
输入：nums = [4,5,2,1], queries = [3,10,21]
输出：[2,3,4]
解释：queries 对应的 answer 如下：
- 子序列 [2,1] 的和小于或等于 3 。可以证明满足题目要求的子序列的最大长度是 2 ，所以 answer[0] = 2 。
- 子序列 [4,5,1] 的和小于或等于 10 。可以证明满足题目要求的子序列的最大长度是 3 ，所以 answer[1] = 3 。
- 子序列 [4,5,2,1] 的和小于或等于 21 。可以证明满足题目要求的子序列的最大长度是 4 ，所以 answer[2] = 4 。
示例 2：
输入：nums = [2,3,4,5], queries = [1]
输出：[0]
解释：空子序列是唯一一个满足元素和小于或等于 1 的子序列，所以 answer[0] = 0 。

解答：
int cmp(const void* a, const void* b) {
    return (*(int*)a - *(int*)b);       //升序排列
}
int* answerQueries(int* nums, int numsSize, int* queries, int queriesSize, int* returnSize) {
    //nums = [4,5,2,1], queries = [3,10,21]
    qsort(nums, numsSize, sizeof(int), cmp);
    //此时nums = [1,2,4,5]，queries = [3,10,21]
    for(int i = 1; i < numsSize; i++)
        nums[i] += nums[i - 1];
    for(int i = 0; i < queriesSize; i++){
        int left = 0, right = numsSize - 1;
        while(left <= right){
            int mid = left + (right - left) / 2;
            if(nums[mid] <= queries[i])
                left = mid + 1;
            else
                right = mid - 1;
        }
        queries[i] = left;
    }
    *returnSize = queriesSize;

    return queries;
}

流程:
详细和我讲一下输入为nums = [4,5,2,1], queries = [3,10,21]时代码的执行逻辑

排序 nums 数组：
qsort(nums, numsSize, sizeof(int), cmp);
使用 qsort 函数对 nums 数组进行升序排序。排序后的 nums 数组为：
nums = [1, 2, 4, 5]

计算前缀和：
for(int i = 1; i < numsSize; i++)
nums[i] += nums[i - 1];
计算前缀和，更新 nums 数组。每个元素表示从第一个元素到当前元素的累加和。计算过程如下：
nums[1] += nums[0] -> nums[1] = 2 + 1 = 3
nums[2] += nums[1] -> nums[2] = 4 + 3 = 7
nums[3] += nums[2] -> nums[3] = 5 + 7 = 12
更新后的 nums 数组为：
nums = [1, 3, 7, 12]    //第一项不变，前一项+第二项,前一项+第三项，前一项+第四项


二分查找

详细解释
初始化 left 和 right
int left = 0, right = numsSize - 1;
left 初始化为 0，表示数组的起始位置。
right 初始化为 numsSize - 1，表示数组的末尾位置。
判断条件 left <= right
while(left <= right){
这个条件表示只要 left 小于或等于 right，循环就继续进行。
当 left 超过 right 时，表示查找范围已经无效，循环终止。
计算中间位置 mid
int mid = left + (right - left) / 2;
计算当前查找范围的中间位置 mid。
这种计算方式可以避免直接使用 (left + right) / 2 可能导致的整数溢出问题。
判断 nums[mid] 和 queries[i] 的关系
if(nums[mid] <= queries[i])
    left = mid + 1;
else
    right = mid - 1;
如果 nums[mid] 小于或等于 queries[i]，说明 mid 及其左侧的元素都满足条件，因此将 left 移动到 mid + 1，继续在右侧查找。
如果 nums[mid] 大于 queries[i]，说明 mid 及其右侧的元素都不满足条件，因此将 right 移动到 mid - 1，继续在左侧查找。
具体例子
输入
nums = [1, 3, 7, 12]（已经排序并计算前缀和）
queries = [3, 10, 21]
处理 queries[0] = 3
初始状态：
left = 0
right = 3（numsSize - 1）
第一次迭代：
mid = 1
nums[1] = 3，满足 nums[mid] <= queries[i]，所以 left = mid + 1 = 2
第二次迭代：
mid = 2
nums[2] = 7，不满足 nums[mid] <= queries[i]，所以 right = mid - 1 = 1
终止条件：
left = 2
right = 1
left > right，循环终止
最终，queries[0] 被更新为 left 的值，即 2。

right 初始化为 numsSize - 1 是为了覆盖整个数组的范围。
判断条件 left <= right 是为了确保查找范围有效。
if(nums[mid] <= queries[i]) 和 else 分支用于调整查找范围，确保找到满足条件的最大索引。


2180
题目:
给你一个正整数 num ，请你统计并返回 小于或等于 num 且各位数字之和为 偶数 的正整数的数目。
正整数的 各位数字之和 是其所有位上的对应数字相加的结果。

示例 1：
输入：num = 4
输出：2
解释：
只有 2 和 4 满足小于等于 4 且各位数字之和为偶数。    
示例 2：
输入：num = 30
输出：14
解释：
只有 14 个整数满足小于等于 30 且各位数字之和为偶数，分别是： 
2、4、6、8、11、13、15、17、19、20、22、24、26 和 28 。
解答：
go.c文件
int getDigitSum(int num) {
    int sum = 0;
    while (num > 0) {
        sum += num % 10;
        num /= 10;
    }
    return sum;
}

int countEven(int num) {
    int even = 0;
    for (int i = 1; i <= num; i++) {
        if (getDigitSum(i) % 2 == 0) {
            even++;
        }
    }
    return even;
} 

--------------------------------------------------

2215
题目:
给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，请你返回一个长度为 2 的列表 answer ，其中：
answer[0] 是 nums1 中所有 不 存在于 nums2 中的 不同 整数组成的列表。
answer[1] 是 nums2 中所有 不 存在于 nums1 中的 不同 整数组成的列表。
注意：列表中的整数可以按 任意 顺序返回。

示例 1：
输入：nums1 = [1,2,3], nums2 = [2,4,6]
输出：[[1,3],[4,6]]
解释：
对于 nums1 ，nums1[1] = 2 出现在 nums2 中下标 0 处，然而 nums1[0] = 1 和 nums1[2] = 3 没有出现在 nums2 中。因此，answer[0] = [1,3]。
对于 nums2 ，nums2[0] = 2 出现在 nums1 中下标 1 处，然而 nums2[1] = 4 和 nums2[2] = 6 没有出现在 nums2 中。因此，answer[1] = [4,6]。
示例 2：
输入：nums1 = [1,2,3,3], nums2 = [1,1,2,2]
输出：[[3],[]]
解释：
对于 nums1 ，nums1[2] 和 nums1[3] 没有出现在 nums2 中。由于 nums1[2] == nums1[3] ，二者的值只需要在 answer[0] 中出现一次，故 answer[0] = [3]。
nums2 中的每个整数都在 nums1 中出现，因此，answer[1] = [] 。 

解答：
go.c文件
int** findDifference(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize, int** returnColumnSizes) {
    int hash1[2001] = { 0 };
    int hash2[2001] = { 0 };
    int** ans = (int**)malloc(sizeof(int*)*2);
    ans[0] = (int*)malloc(sizeof(int)*nums1Size);
    ans[1] = (int*)malloc(sizeof(int)*nums2Size);

    int diff1 = 0;
    int diff2 = 0;

    int i = 0;
    for (i = 0; i < nums2Size; i++)
    {
        hash1[1000-nums2[i]] += 1;
    }

    for (i = 0; i < nums1Size; i++)
    {
        hash2[1000-nums1[i]] += 1;
    }
    //
    for (i = 0; i < nums1Size; i++)
    {
        if (hash1[1000-nums1[i]] == 0)
        {
            ans[0][diff1++] = nums1[i];
            hash1[1000-nums1[i]] += 1;
        }
    }

    for (i = 0; i < nums2Size; i++)
    {
        if (hash2[1000-nums2[i]] == 0)
        {
            ans[1][diff2++] = nums2[i];
            hash2[1000-nums2[i]] += 1;
        }
    }    

    *returnColumnSizes = (int*)malloc(sizeof(int)*2);

    (*returnColumnSizes)[0] = diff1;
    (*returnColumnSizes)[1] = diff2;
    
    *returnSize = 2;
    return ans;
}
参数nums1 = [1,2,3], nums2 = [2,4,6]

------------------------------------------------------
1971

题目:
有一个具有 n 个顶点的 双向 图，其中每个顶点标记从 0 到 n - 1（包含 0 和 n - 1）。图中的边用一个二维整数数组 edges 表示，其中 edges[i] = [ui, vi] 表示顶点 ui 和顶点 vi 之间的双向边。 每个顶点对由 最多一条 边连接，并且没有顶点存在与自身相连的边。
请你确定是否存在从顶点 source 开始，到顶点 destination 结束的 有效路径 。
给你数组 edges 和整数 n、source 和 destination，如果从 source 到 destination 存在 有效路径 ，则返回 true，否则返回 false 。

示例 1：
输入：n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2
edges决定：
  0
 / \
1 - 2
输出：true
解释：存在由顶点 0 到顶点 2 的路径:
- 0 → 1 → 2 
- 0 → 2

示例 2：
输入：n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5
由edges决定：
  0     3
 / \   / \
1   2 4 - 5
输出：false
解释：不存在由顶点 0 到顶点 5 的路径.


解答：
go.c文件
int setFind(int *set,int u){
    if(u==set[u])return u;
    else return set[u]=setFind(set,set[u]);
}
bool isSameSet(int *set,int u, int v){
    u=setFind(set,u);
    v=setFind(set,v);
    return u==v;
}
void setJoin(int *set, int u, int v){
    u=setFind(set,u);
    v=setFind(set,v);
    if(u==v)return;
    set[u]=v;
}
bool validPath(int n, int** edges, int edgesSize, int* edgesColSize, int source, int destination) {
    int *set=malloc(sizeof(int)*n);
    for(int i=0;i<n;i++)set[i]=i;
    for(int i=0;i<edgesSize;i++) setJoin(set,edges[i][0],edges[i][1]);
    return isSameSet(set,source,destination);
}

传入参数n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2


使用并查集（Union-Find）算法解决这个问题
初始化：每个节点开始时是一个独立的集合。
连接操作：对于每一条边，将连接的两个节点合并到一个集合中。
查找操作：最终检查 source 和 destination 是否在同一个集合中。

具体步骤如下：
创建一个数组 set，初始化时每个节点指向自身。
遍历 edges 数组，对每一条边执行 union 操作，将两个节点合并到同一个集合中。
最后，检查 source 和 destination 是否属于同一个集合。
通过这些步骤，可以高效地判断是否存在从 source 到 destination 的路径。

代码解释
并查集的函数
setFind：查找集合的根节点，并进行路径压缩优化。
isSameSet：检查两个节点是否在同一个集合中。
setJoin：将两个节点的集合合并。
主函数
validPath：初始化并查集，对所有边进行合并操作，最后检查源节点和目标节点是否在同一个集合中。

什么是根节点？
在并查集（Union-Find）中，根节点（Root Node）是集合中的代表元素。每个集合通过一个树结构表示，树的根节点是树中唯一一个没有父节点的节点。

图形化解释
初始化
假设有 3 个顶点（0, 1, 2），初始时每个顶点都是一个独立的集合：
 0   1   2
(自成一体)
对应的 set 数组：
set = [0, 1, 2]
每个顶点是自己的根节点。

处理每条边

边 [0, 1]
调用 setJoin(set, 0, 1)：
查找根节点：
setFind(set, 0) 返回 0
setFind(set, 1) 返回 1
合并集合：
将 0 的根节点设为 1：       以后将0连别的节点都会重定向至1
set[0] = 1
更新后的 set 数组：
set = [1, 1, 2]
图形化表示：
 0 - 1   2

边 [1, 2]
调用 setJoin(set, 1, 2)：
查找根节点：
setFind(set, 1) 返回 1
setFind(set, 2) 返回 2
合并集合：
将 1 的根节点设为 2：
set[1] = 2
更新后的 set 数组：
set = [1, 2, 2]
图形化表示：
 0 - 1 - 2

边 [2, 0]
调用 setJoin(set, 2, 0)：
查找根节点：
setFind(set, 2) 返回 2
setFind(set, 0) 需要路径压缩：
setFind(set, 0) 调用 setFind(set, 1)
setFind(set, 1) 调用 setFind(set, 2) 返回 2
路径压缩后，set[0] = 2
合并集合：
0 和 2 已在同一个集合中（根节点相同），无需合并。
更新后的 set 数组保持不变：
set = [2, 2, 2]
图形化表示：
 0 - 1 - 2
(已连通)

检查路径
调用 isSameSet(set, source, destination)：
查找根节点：
setFind(set, 0) 返回 2
setFind(set, 2) 返回 2
根相同，返回 true。
总结
通过并查集的操作，图中的所有顶点被连接成一个集合，最后检查源和目标是否在同一个集合中：
 0 - 1 - 2
这意味着存在从 0 到 2 的有效路径。

------------------------------------------------------
2103
题目:
总计有 n 个环，环的颜色可以是红、绿、蓝中的一种。这些环分别穿在 10 根编号为 0 到 9 的杆上。
给你一个长度为 2n 的字符串 rings ，表示这 n 个环在杆上的分布。rings 中每两个字符形成一个 颜色位置对 ，用于描述每个环：
第 i 对中的 第一个 字符表示第 i 个环的 颜色（'R'、'G'、'B'）。
第 i 对中的 第二个 字符表示第 i 个环的 位置，也就是位于哪根杆上（'0' 到 '9'）。
例如，"R3G2B1" 表示：共有 n == 3 个环，红色的环在编号为 3 的杆上，绿色的环在编号为 2 的杆上，蓝色的环在编号为 1 的杆上。
找出所有集齐 全部三种颜色 环的杆，并返回这种杆的数量。

示例 1：
输入：rings = "B0B6G0R6R0R6G9"
输出：1
解释：
- 编号 0 的杆上有 3 个环，集齐全部颜色：红、绿、蓝。
- 编号 6 的杆上有 3 个环，但只有红、蓝两种颜色。
- 编号 9 的杆上只有 1 个绿色环。
因此，集齐全部三种颜色环的杆的数目为 1 。
示例 2：
输入：rings = "B0R0G0R9R0B0G0"
输出：1
解释：
- 编号 0 的杆上有 6 个环，集齐全部颜色：红、绿、蓝。
- 编号 9 的杆上只有 1 个红色环。
因此，集齐全部三种颜色环的杆的数目为 1 。
示例 3：
输入：rings = "G4"
输出：0
解释：
只给了一个环，因此，不存在集齐全部三种颜色环的杆。
解答：
go.c文件
int countPoints(char* rings) {
    int d['Z'];
    memset(d, 0, sizeof(d));
    d['R'] = 1;
    d['G'] = 2;
    d['B'] = 4;

    int mask[10];
    memset(mask, 0, sizeof(mask));

    for (int i = 0, n = strlen(rings); i < n; i += 2) {
        int c = rings[i];
        int j = rings[i + 1] - '0';
        mask[j] |= d[c];
    }

    int ans = 0;
    for (int i = 0; i < 10; i++) {
        if (mask[i] == 7) {
            ans++;
        }
    }

    return ans;
}
main.c文件:
#include "go.c"

1.请帮我写main.c中的main函数，调用go.c中的countPoints函数并传入参数rings = "B0B6G0R6R0R6G9"
2.通过示例1详细和我讲一下这个代码发了执行过程。最好使用图形化的方式帮助理解。
3.如果解决代码使用了某种算法，请向我说明并介绍它

示例1详细解释代码执行过程：
输入字符串为 rings = "B0B6G0R6R0R6G9"。我们将以图形化的方式展示代码的执行过程。
初始化映射数组 d 用于颜色到二进制数值的映射：
d['R'] = 1 (0001 in binary)
d['G'] = 2 (0010 in binary)
d['B'] = 4 (0100 in binary)
初始化杆状态数组 mask 为0:

mask[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
遍历输入字符串 rings，每两个字符作为一对（颜色, 杆位置），更新杆的状态。

B0 -> 蓝色环在杆 0:
mask[0] |= d['B'] -> mask[0] |= 4 -> mask[0] = 0100
mask = {4, 0, 0, 0, 0, 0, 0, 0, 0, 0}
B6 -> 蓝色环在杆 6:
mask[6] |= d['B'] -> mask[6] |= 4 -> mask[6] = 0100
mask = {4, 0, 0, 0, 0, 0, 4, 0, 0, 0}
G0 -> 绿色环在杆 0:
mask[0] |= d['G'] -> mask[0] |= 2 -> mask[0] = 0100 | 0010 = 0110
mask = {6, 0, 0, 0, 0, 0, 4, 0, 0, 0}
R6 -> 红色环在杆 6:
mask[6] |= d['R'] -> mask[6] |= 1 -> mask[6] = 0100 | 0001 = 0101
mask = {6, 0, 0, 0, 0, 0, 5, 0, 0, 0}
R0 -> 红色环在杆 0:
mask[0] |= d['R'] -> mask[0] |= 1 -> mask[0] = 0110 | 0001 = 0111
mask = {7, 0, 0, 0, 0, 0, 5, 0, 0, 0}
R6 -> 红色环在杆 6（已存在）:
mask[6] |= d['R'] -> mask[6] |= 1 -> mask[6] = 0101 | 0001 = 0101
mask = {7, 0, 0, 0, 0, 0, 5, 0, 0, 0}
G9 -> 绿色环在杆 9:
mask[9] |= d['G'] -> mask[9] |= 2 -> mask[9] = 0010
mask = {7, 0, 0, 0, 0, 0, 5, 0, 0, 2}
检查每个杆的状态，计数拥有所有三种颜色（R、G、B）的杆：

int ans = 0;
for (int i = 0; i < 10; i++) {
    if (mask[i] == 7) {
        ans++;
    }
}
遍历 mask 数组，找到值为 7（即二进制 111）的项，计数 ans
mask[0] = 0111 -> all three colors
mask[6] = 0101 -> not all three colors
mask[9] = 0010 -> not all three colors
结果是1个杆（杆0）拥有所有三种颜色。

这个代码使用了位掩码（bitmask）/位图 算法。
位掩码算法介绍：

位掩码是一示种使用二进制位来表状态的技术。在本题中，我们使用位掩码表示每个杆上的颜色状态：

红色 R 用 0001 表示。
绿色 G 用 0010 表示。
蓝色 B 用 0100 表示。
通过使用按位或运算（|=），我们可以将颜色的状态组合在一起。例如，如果一个杆上有红色和绿色的环，那么其位掩码值为 0001 | 0010 = 0011。如果一个杆上的掩码值为 0111（即 7），则表示该杆上集齐了所有三种颜色的环。

这种方法的优点是状态表示紧凑且操作效率高，可以通过简单的按位运算快速更新和检查状态。

memset:
memset 是 C 标准库中的一个函数，用于将一块内存中的所有字节设置为指定的值。其原型为：
void *memset(void *s, int c, size_t n);
s 是指向要填充的内存块的指针。
c 是要设置的值（以无符号字符形式）。
n 是要填充的字节数。
在代码中，memset(d, 0, sizeof(d)); 的作用是将数组 d 的所有元素设置为 0。类似地，memset(mask, 0, sizeof(mask)); 将数组 mask 的所有元素设置为 0。

malloc
malloc（memory allocation）用于动态分配内存。它在堆上分配指定大小的连续内存块，并返回指向该内存块的指针。如果分配失败，返回 NULL。

int* ptr = (int*)malloc(10 * sizeof(int));
分配一个足够存储 10 个 int 类型数据的内存块。       ptr数组就有10个长度
将返回的 void* 指针转换为 int* 指针。
将转换后的 int* 指针赋值给 ptr 变量，这样 ptr 就指向了分配的内存块。

通常，malloc 和 memset 会组合使用。首先使用 malloc 分配内存，然后使用 memset 初始化内存。例如：
int* ptr = (int*)malloc(10 * sizeof(int)); // 分配内存
if (ptr != NULL) {
    memset(ptr, 0, 10 * sizeof(int));      // 初始化内存
}

----------------------------------------------------------
1377
题目:
给你一个大小为 m * n 的矩阵 mat，矩阵由若干军人和平民组成，分别用 1 和 0 表示。
请你返回矩阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。
如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但 i 小于 j，那么我们认为第 i 行的战斗力比第 j 行弱。
军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。

示例 1：
输入：mat = 
[[1,1,0,0,0],
 [1,1,1,1,0],
 [1,0,0,0,0],
 [1,1,0,0,0],
 [1,1,1,1,1]], 
k = 3
输出：[2,0,3]
解释：
每行中的军人数目：
行 0 -> 2 
行 1 -> 4 
行 2 -> 1 
行 3 -> 2 
行 4 -> 5 
从最弱到最强对这些行排序后得到 [2,0,3,1,4]
示例 2：
输入：mat = 
[[1,0,0,0],
 [1,1,1,1],
 [1,0,0,0],
 [1,0,0,0]], 
k = 2
输出：[0,2]
解释： 
每行中的军人数目：
行 0 -> 1 
行 1 -> 4 
行 2 -> 1 
行 3 -> 1 
从最弱到最强对这些行排序后得到 [0,2,3,1]
解答：
go.c文件
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int comp(const void *a, const void *b)
{
    return *(int*)a - *(int*)b;
}
int* kWeakestRows(int** mat, int matSize, int* matColSize, int k, int* returnSize) 
{
    int *ret = malloc(sizeof(int) * k);
    int *hash = malloc(sizeof(int) * matSize);
    for(int i = 0; i < matSize; i++)
    {
        int count = 0;
        for(int j = 0; j < * matColSize; j++)
        {
            if(mat[i][j] == 1)
            {
                count++;
            }
        }
        hash[i] = count * 100 + i;  //方便找索引
    }
    qsort(hash, matSize, sizeof(int), comp);
    int j = 0;
    for(int i = 0; i < k; i++)
    {
        ret[j++] = hash[i] % 100;   //转化为索引
    }
    * returnSize = k;
    return ret;
}

1.通过示例1详细和我讲一下这个代码发了执行过程。最好使用图形化的方式帮助理解。

计算军人数量并填充 hash 数组：
第 0 行：2 个军人，hash[0] = 2 * 100 + 0 = 200
第 1 行：4 个军人，hash[1] = 4 * 100 + 1 = 401
第 2 行：1 个军人，hash[2] = 1 * 100 + 2 = 102
第 3 行：2 个军人，hash[3] = 2 * 100 + 3 = 203
第 4 行：5 个军人，hash[4] = 5 * 100 + 4 = 504

排序 hash 数组：
排序前：[200, 401, 102, 203, 504]
排序后：[102, 200, 203, 401, 504]

--------------------------------------------------
//1260
题目:
给你一个 m 行 n 列的二维网格 grid 和一个整数 k。你需要将 grid 迁移 k 次。
每次「迁移」操作将会引发下述活动：
位于 grid[i][j] 的元素将会移动到 grid[i][j + 1]。
位于 grid[i][n - 1] 的元素将会移动到 grid[i + 1][0]。
位于 grid[m - 1][n - 1] 的元素将会移动到 grid[0][0]。
请你返回 k 次迁移操作后最终得到的 二维网格。

示例 1：
输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1
输出：[[9,1,2],[3,4,5],[6,7,8]]
示例 2：
输入：grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4
输出：[[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]
示例 3：
输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9
输出：[[1,2,3],[4,5,6],[7,8,9]]
解答：
go.c文件
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** shiftGrid(int** grid, int row, int* gridCol, int k, int* returnSize, int** returnCol)
{
    int col = *gridCol;
    *returnSize = row;
    *returnCol = (int*)malloc(sizeof(int) * row);
    int** ans = (int**)malloc(sizeof(int*) * row);
    k %= (row * col);
    for(int i = 0; i < row; i++)
    {
        (*returnCol)[i] = col;
        ans[i] = (int*)malloc(sizeof(int) * col);
        for(int j = 0; j < col; j++)
        {
            int id =  (row * col + i * col + j - k ) % (row * col);
            ans[i][j] = grid[id / col][id % col];
        }
    }
    return ans;
}


(0,0) -> (0,1):

id = (9 + 0*3 + 0 - 1) % 9 = 8
id / col = 8 / 3 = 2
id % col = 8 % 3 = 2
ans[0][0] = grid[2][2] = 9
(0,1) -> (0,2):

id = (9 + 0*3 + 1 - 1) % 9 = 0
id / col = 0 / 3 = 0
id % col = 0 % 3 = 0
ans[0][1] = grid[0][0] = 1
(0,2) -> (1,0):

id = (9 + 0*3 + 2 - 1) % 9 = 1
id / col = 1 / 3 = 0
id % col = 1 % 3 = 1
ans[0][2] = grid[0][1] = 2
第1行：

(1,0) -> (1,1):

id = (9 + 1*3 + 0 - 1) % 9 = 2
id / col = 2 / 3 = 0
id % col = 2 % 3 = 2
ans[1][0] = grid[0][2] = 3

………………

---------------------------------------------------------
1122
题目:
给你两个数组，arr1 和 arr2，arr2 中的元素各不相同，arr2 中的每个元素都出现在 arr1 中。
对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。

示例 1：
输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
输出：[2,2,2,1,4,3,3,9,6,7,19]
示例  2:
输入：arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6]
输出：[22,28,8,6,17,44]
解答：
go.c文件
int* relativeSortArray(int* arr1, int arr1Size, int* arr2, int arr2Size, int* returnSize){
    int index = 0;
    int hash[1001] = {0};
    for (int i = 0; i < arr1Size; ++i) {
        hash[arr1[i]]++;
    }

    for (int i = 0; i < arr2Size; ++i) {
        while (hash[arr2[i]] > 0) {
            arr1[index++] = arr2[i];
            hash[arr2[i]]--;
        }
    }

    for (int i = 0; i < 1001; ++i) {
        while (hash[i] > 0) {
            arr1[index++] = i;
            hash[i]--;
        }
    }

    *returnSize = arr1Size;
    return arr1;
}

---------------------------------------------------
1313
题目:
给你一个以行程长度编码压缩的整数列表 nums 。
考虑每对相邻的两个元素 [freq, val] = [nums[2*i], nums[2*i+1]] （其中 i >= 0 ），每一对都表示解压后子列表中有 freq 个值为 val 的元素，你需要从左到右连接所有子列表以生成解压后的列表。
请你返回解压后的列表。

示例 1：
输入：nums = [1,2,3,4]
输出：[2,4,4,4]
解释：第一对 [1,2] 代表着 2 的出现频次为 1，所以生成数组 [2]。
第二对 [3,4] 代表着 4 的出现频次为 3，所以生成数组 [4,4,4]。
最后将它们串联到一起 [2] + [4,4,4] = [2,4,4,4]。
示例 2：
输入：nums = [1,1,2,3]
输出：[1,3,3]
解答：
go.c文件

int* decompressRLElist(int* nums, int numsSize, int* returnSize) {
    int i, j, k, count;
    int *res;
    k = 0;
    count = 0;
    for (i = 0; i < numsSize; i += 2)
    {
        count += nums[i];
    }
    *returnSize = count;
    res = (int *)malloc(sizeof(int) * count);
    for (i = 1; i < numsSize; i += 2)
    {
        for (j = 0; j < nums[i - 1]; j++)
        {
            res[k] = nums[i];
            k++;
        }
    }
    return res;
}
-----------------------------------------------
1351
题目:
给你一个 m * n 的矩阵 grid，矩阵中的元素无论是按行还是按列，都以非严格递减顺序排列。 请你统计并返回 grid 中 负数 的数目。

示例 1：
输入：grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]
输出：8
解释：矩阵中共有 8 个负数。
示例 2：
输入：grid = [[3,2],[1,0]]
输出：0
解答：
go.c文件
int countNegatives(int **grid, int gridSize, int *gridColSize) {
    int ans = 0;
    int Row = gridSize;
    int Col = gridColSize[0];
    for (int i = 0, j = Col; i < Row; i++) {
        while (j > 0 && grid[i][j - 1] < 0) {
            j--;
        }
        ans += Col - j;
    }
    return ans;
}

-----------------------------------------------
1403
题目:
给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。
如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。
与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。
注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。

示例 1：
输入：nums = [4,3,10,9,8]
输出：[10,9] 
解释：子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。 
示例 2：
输入：nums = [4,4,7,6,7]
输出：[7,7,6] 
解释：子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 = 4 + 4 + 6）。因此，[7,6,7] 是满足题意的最小子序列。注意，元素按非递增顺序返回。  
解答：
go.c文件
int cmp(const void *a, const void *b)
{
    return *(int*)b - *(int*)a;
}

int* minSubsequence(int* nums, int numsSize, int* returnSize) 
{
    qsort(nums, numsSize, sizeof(int), cmp);
    int *temp = (int*)malloc(sizeof(int)*numsSize);
    temp[0] = nums[0];
    int sum = nums[0];
    for(int i = 1; i < numsSize; i++)
    {
        sum += nums[i];
        temp[i] = temp[i - 1] + nums[i];
        // temp保存前缀和
    }

    int index = 0;
    for(int i = 0; i < numsSize; i++)
    {
        int small = sum - temp[i];
        if(small < temp[i])
        {
            index = i;
            break;
        }
    }
    free(temp);
    *returnSize = index + 1;
    int* res = (int*)malloc(sizeof(int) * (index + 1));
    for(int i = 0; i <= index; i++)
    {
        res[i] = nums[i];
    }
    return res;
}

初始化 temp 数组来存储前缀和：
temp[0] = nums[0] = 10
temp[1] = temp[0] + nums[1] = 10 + 9 = 19
temp[2] = temp[1] + nums[2] = 19 + 8 = 27
temp[3] = temp[2] + nums[3] = 27 + 4 = 31
temp[4] = temp[3] + nums[4] = 31 + 3 = 34
整个数组的和 sum = 34。

i = 0：small = sum - temp[0] = 34 - 10 = 24 (不满足 24 < 10)
i = 1：small = sum - temp[1] = 34 - 19 = 15 (不满足 15 < 19)
i = 2：small = sum - temp[2] = 34 - 27 = 7 (满足 7 < 27)
找到满足条件的位置 index = 2。

returnSize = index + 1 = 3
构建结果数组 res = [10, 9, 8]。



------------------------------------------------
中等题
面试题 16.04. 井字游戏
题目:
设计一个算法，判断玩家是否赢了井字游戏。输入是一个 N x N 的数组棋盘，由字符" "，"X"和"O"组成，其中字符" "代表一个空位。
以下是井字游戏的规则：

玩家轮流将字符放入空位（" "）中。
第一个玩家总是放字符"O"，且第二个玩家总是放字符"X"。
"X"和"O"只允许放置在空位中，不允许对已放有字符的位置进行填充。
当有N个相同（且非空）的字符填充任何行、列或对角线时，游戏结束，对应该字符的玩家获胜。
当所有位置非空时，也算为游戏结束。
如果游戏结束，玩家不允许再放置字符。
如果游戏存在获胜者，就返回该游戏的获胜者使用的字符（"X"或"O"）；如果游戏以平局结束，则返回 "Draw"；如果仍会有行动（游戏未结束），则返回 "Pending"。

示例 1：
输入： board = ["O X"," XO","X O"]
输出： "X"
示例 2：
输入： board = ["OOX","XXO","OXO"]
输出： "Draw"
解释： 没有玩家获胜且不存在空位
示例 3：
输入： board = ["OOX","XXO","OX "]
输出： "Pending"
解释： 没有玩家获胜且仍存在空位
解答：
go.c文件
char* tictactoe(char** board, int boardSize){
    //O   X
    //  X O
    //X   O
    //当有N个相同（且非空）的字符填充任何行、列或对角线时，游戏结束，对应该字符的玩家获胜。
    //统计每一行，每一列，对角线上面，‘O’和‘X’字符的个数
    int oCnt = 0;
    int xCnt = 0;
    for(int i = 0; i < boardSize;i++){
        oCnt = 0;
        xCnt = 0;
        for(int j = 0; j < boardSize;j++) {
            if(board[i][j] == 'O')
                oCnt++;
            else if(board[i][j] == 'X')
                xCnt++;
        }

        if(oCnt == boardSize || xCnt == boardSize)
            return oCnt == boardSize?"O":"X";
    }

    for(int i = 0; i < boardSize;i++){
        oCnt = 0;
        xCnt = 0;
        for(int j = 0; j < boardSize;j++) {
            if(board[j][i] == 'O')
                oCnt++;
            else if(board[j][i] == 'X')
                xCnt++;
        }

        if(oCnt == boardSize || xCnt == boardSize)
            return oCnt == boardSize?"O":"X";
    }


    //对角线
    oCnt = 0;
    xCnt = 0;
    for(int i = 0; i < boardSize;i++){
        if(board[i][i] == 'O')
            oCnt++;
        else if(board[i][i] == 'X')
            xCnt++;
    }

    if(oCnt == boardSize || xCnt == boardSize)
        return oCnt == boardSize?"O":"X";

    //反对角线
    oCnt = 0;
    xCnt = 0;
    for(int i = 0; i < boardSize;i++){
        if(board[i][boardSize - i - 1] == 'O')
            oCnt++;
        else if(board[i][boardSize - i - 1] == 'X')
            xCnt++;
    }

    if(oCnt == boardSize || xCnt == boardSize)
        return oCnt == boardSize?"O":"X";
    
    oCnt = 0;
    xCnt = 0;
    for(int i = 0; i < boardSize;i++){
        for(int j = 0; j < boardSize;j++) {
            if(board[i][j] == 'O')
                oCnt++;
            else if(board[i][j] == 'X')
                xCnt++;
        }
    }

    printf("%d %d %d\n",oCnt,xCnt,boardSize * boardSize);
    //走到这里，说明还没有玩家获胜
    return oCnt + xCnt == boardSize * boardSize?"Draw":"Pending";

};
--------------------------------------------------------
面试题 17.09. 第k个数
题目:
有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。

示例 1:
输入: k = 5
输出: 9
解答：
go.c文件
int getKthMagicNumber(int k){
    int dp[k+1];
    dp[1] = 1;
    int p3 =1, p5=1,p7 = 1;
    for(int i=2;i<=k;i++){
        int num3 = dp[p3] *3,num5 = dp[p5]*5,num7 = dp[p7]*7;
        dp[i] = fmin(fmin(num3,num5),num7);
        if(dp[i] == num3){
            p3++;
        }
        if(dp[i] == num5){
            p5++;
        }
        if(dp[i] == num7){
            p7++;
        }
    }
    return dp[k];
}

另一种：
int getKthMagicNumber(int k) {
    int dp[k + 1];
    dp[1] = 1;
    int p3 = 1, p5 = 1, p7 = 1;
    for (int i = 2; i <= k; i++) {
        int num3 = dp[p3] * 3, num5 = dp[p5] * 5, num7 = dp[p7] * 7;
        dp[i] = fmin(fmin(num3, num5), num7);
        if (dp[i] == num3) {
            p3++;
        }
        if (dp[i] == num5) {
            p5++;
        }
        if (dp[i] == num7) {
            p7++;
        }
    }
    return dp[k];
}
这个方法使用的是动态规划（Dynamic Programming）结合三指针法（Three-pointer Method）来生成符合条件的数列。这种方法有效地找出了只包含素因子 3、5 和 7 的数列中的第 k 个数。
详细解释
动态规划（Dynamic Programming）
动态规划是一种将复杂问题分解成更小子问题的方法，通过存储子问题的解避免重复计算，从而提高效率。在这个方法中，我们使用一个数组 dp 来存储符合条件的数列。
三指针法（Three-pointer Method）
三指针法是一种利用多个指针来追踪数组不同部分的方法。在这个具体的问题中，三指针法用来生成只包含素因子 3、5 和 7 的数列。

例子：k = 5
我们通过例子来详细理解这段代码的执行过程：

初始化：
dp = [1, 1, 0, 0, 0, 0]
p3 = 1, p5 = 1, p7 = 1
迭代过程：
i = 2:
num3 = dp[1] * 3 = 3
num5 = dp[1] * 5 = 5
num7 = dp[1] * 7 = 7
dp[2] = min(3, 5, 7) = 3
更新指针 p3 = 2
dp = [1, 1, 3, 0, 0, 0]
p3 = 2, p5 = 1, p7 = 1
i = 3:
num3 = dp[2] * 3 = 9
num5 = dp[1] * 5 = 5
num7 = dp[1] * 7 = 7
dp[3] = min(9, 5, 7) = 5
更新指针 p5 = 2
dp = [1, 1, 3, 5, 0, 0]
p3 = 2, p5 = 2, p7 = 1
i = 4:
num3 = dp[2] * 3 = 9
num5 = dp[2] * 5 = 15
num7 = dp[1] * 7 = 7
dp[4] = min(9, 15, 7) = 7
更新指针 p7 = 2
dp = [1, 1, 3, 5, 7, 0]
p3 = 2, p5 = 2, p7 = 2
i = 5:
num3 = dp[2] * 3 = 9
num5 = dp[2] * 5 = 15
num7 = dp[2] * 7 = 21
dp[5] = min(9, 15, 21) = 9
更新指针 p3 = 3
dp = [1, 1, 3, 5, 7, 9]
p3 = 3, p5 = 2, p7 = 2
最后，返回 dp[5]，即 9。

规律
每次选择的数都是上一次生成的数乘以 3、5 或 7 中的最小值。
每选择一次，就相应地更新指针，确保每个数只被乘以对应的素因子一次。
--------------------------------------------------
LRC 166. 珠宝的最高价值
题目:
现有一个记作二维矩阵 frame 的珠宝架，其中 frame[i][j] 为该位置珠宝的价值。拿取珠宝的规则为：
只能从架子的左上角开始拿珠宝
每次可以移动到右侧或下侧的相邻位置
到达珠宝架子的右下角时，停止拿取
注意：珠宝的价值都是大于 0 的。除非这个架子上没有任何珠宝，比如 frame = [[0]]。

示例 1:
输入: frame = [[1,3,1],[1,5,1],[4,2,1]]
输出: 12
解释: 路径 1→3→5→2→1 可以拿到最高价值的珠宝
解答：
go.c文件
int jewelleryValue(int** grid, int gridSize, int* gridColSize){
    int m=gridSize,n=gridColSize[0];
    int f[m][n];
    memset(f,0,sizeof(f));
    //从左上角开始(0,0)
    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            //i>0说明已经上面有元素
            if(i>0){
                f[i][j]=f[i][j]>f[i-1][j]?f[i][j]:f[i-1][j];
            }
            if(j>0){
            //j>0说明以及左边有元素
                f[i][j]=f[i][j]>f[i][j-1]?f[i][j]:f[i][j-1];
            }
            //f[i][j]的值是上面和左边的的最大的一边
            f[i][j]+=grid[i][j];
        }
    }
    return f[m-1][n-1];
}

f[0][0] 初始化为 grid[0][0]，即珠宝架左上角的价值。
对于第一行和第一列，只能从左侧或上方移动过来，因此：
f[0][j]=f[0][j−1]+grid[0][j]
f[i][0]=f[i−1][0]+grid[i][0]

通过状态转移方程，逐步计算并填充 f 数组，最后返回 f[m-1][n-1] 作为结果

假设输入 frame = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]，我们希望计算从左上角到右下角的最大珠宝价值。
初始化 f 数组：
1   0   0
0   0   0
0   0   0

计算第一行：
f[0][1]=f[0][0]+grid[0][1]=1+3=4
f[0][2]=f[0][1]+grid[0][2]=4+1=5
计算第一列：
f[1][0]=f[0][0]+grid[1][0]=1+1=2
f[2][0]=f[1][0]+grid[2][0]=2+4=6
1   4   5
2   0   0
6   0   0

计算剩余位置
f[1][1]=grid[1][1]+max(f[0][1],f[1][0])=5+max(4,2)=9
f[1][2]=grid[1][2]+max(f[0][2],f[1][1])=1+max(5,9)=10
f[2][1]=grid[2][1]+max(f[1][1],f[2][0])=2+max(9,6)=11
f[2][2]=grid[2][2]+max(f[1][2],f[2][1])=1+max(10,11)=12
1   4   5
2   9   10
6   11  12

返回结果 f[2][2] = 12，即为从左上角到右下角的最大珠宝价值。
通过动态规划，我们可以有效地计算出从左上角到右下角的最大珠宝价值，并且通过保存中间结果避免了重复计算，从而提高了效率。
--------------------------------------------------
81
题目:
已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。
在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。
给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。
你必须尽可能减少整个操作步骤。

示例 1：
输入：nums = [2,5,6,0,0,1,2], target = 0
输出：true
示例 2：
输入：nums = [2,5,6,0,0,1,2], target = 3
输出：false
解答：
go.c文件
bool search(int* nums, int numsSize, int target) {
    int i;
    for(i = 0; i< numsSize;i++){
        if(nums[i] == target)
        {return true;}
    }
    return false;
}
---------------------------------------------------------
题目:
一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：

'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：

"AAJF" ，将消息分组为 (1 1 10 6)
"KJF" ，将消息分组为 (11 10 6)
注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。
给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。
题目数据保证答案肯定是一个 32 位 的整数。

示例 1：
输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
示例 2：
输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
示例 3：
输入：s = "06"
输出：0
解释："06" 无法映射到 "F" ，因为存在前导零（"6" 和 "06" 并不等价）。
解答：
go.c文件
int numDecodings(char* s) {
    int length = strlen(s);
    int i, k, n = length + 1;
    int dp[n], nums[n];
    dp[0] = 1;
    // 字符数组化为整数数组
    for (i = 1; i < n; i++) { 
        dp[i] = 0;
        nums[i] = s[i - 1] - 48;
    }
    if (nums[1] == 0) {
        return 0;
    } else {
        dp[1] = 1;
    }

    for (i = 2; i < n; i++) {

        k = nums[i - 1] * 10 + nums[i];
        if (nums[i] == 0 && (k >= 30 || k == 0)) { 
            // 1.第i位单独解释不了(即等于0)，加上前一位也还是解释不了，则无解
            return 0; 
        } else if (nums[i] == 0) { 
            // 2.第i位单独解释不了，但是加上前一位可以解释
            dp[i] = dp[i - 2]; 

        } else if (nums[i] != 0) { 
            // 3.第i位单独可以解释
            if (k > 26 || k < 10) {
                // 3.1加上前一位不行
                dp[i] = dp[i - 1];
            } else {
                // 3.2加上前一位可以
                dp[i] = dp[i - 1] + dp[i - 2];
            }
        }
    }
    return dp[n - 1];
}
----------------------------------------------------
题目:
给你一张 无向 图，图中有 n 个节点，节点编号从 0 到 n - 1 （都包括）。同时给你一个下标从 0 开始的整数数组 values ，其中 values[i] 是第 i 个节点的 价值 。同时给你一个下标从 0 开始的二维整数数组 edges ，其中 edges[j] = [uj, vj, timej] 表示节点 uj 和 vj 之间有一条需要 timej 秒才能通过的无向边。最后，给你一个整数 maxTime 。
合法路径 指的是图中任意一条从节点 0 开始，最终回到节点 0 ，且花费的总时间 不超过 maxTime 秒的一条路径。你可以访问一个节点任意次。一条合法路径的 价值 定义为路径中 不同节点 的价值 之和 （每个节点的价值 至多 算入价值总和中一次）。
请你返回一条合法路径的 最大 价值。
注意：每个节点 至多 有 四条 边与之相连。

示例 1：
输入：values = [0,32,10,43], edges = [[0,1,10],[1,2,15],[0,3,10]], maxTime = 49
输出：75
解释：
一条可能的路径为：0 -> 1 -> 0 -> 3 -> 0 。总花费时间为 10 + 10 + 10 + 10 = 40 <= 49 。
访问过的节点为 0 ，1 和 3 ，最大路径价值为 0 + 32 + 43 = 75 。
示例 2：
输入：values = [5,10,15,20], edges = [[0,1,10],[1,2,10],[0,3,10]], maxTime = 30
输出：25
解释：
一条可能的路径为：0 -> 3 -> 0 。总花费时间为 10 + 10 = 20 <= 30 。
访问过的节点为 0 和 3 ，最大路径价值为 5 + 20 = 25 。
示例 3：
输入：values = [1,2,3,4], edges = [[0,1,10],[1,2,11],[2,3,12],[1,3,13]], maxTime = 50
输出：7
解释：
一条可能的路径为：0 -> 1 -> 3 -> 1 -> 0 。总花费时间为 10 + 13 + 13 + 10 = 46 <= 50 。
访问过的节点为 0 ，1 和 3 ，最大路径价值为 1 + 2 + 4 = 7 。
示例 4：
输入：values = [0,1,2], edges = [[1,2,10]], maxTime = 10
输出：0
解释：
唯一一条路径为 0 。总花费时间为 0 。
唯一访问过的节点为 0 ，最大路径价值为 0 。
解答：
go.c文件
int map[1002][4][2];
int length[1002];
int *V;
int path[1002];
int max;
void dfs(int pos,int start,int value,int len,int bound){
    int i,FLAG=0;
    if(path[pos]==0){value+=V[pos];path[pos]=1;FLAG=1;}
    if(pos==start){
        max=fmax(max,value);
    }
    for(i=0;i<length[pos];i++){
        if(len+map[pos][i][1]>bound)continue;
        else dfs(map[pos][i][0],start,value,len+map[pos][i][1],bound);
    }
    if(FLAG==1)path[pos]=0;
    return ;
}
int maximalPathQuality(int* values, int valuesSize, int** edges, int edgesSize, int* edgesColSize, int maxTime){
    //memset(map,0,sizeof(map)); 
    memset(length,0,sizeof(length)); 
    V=values;
     int i,j,k,res=0;
    for(i=0;i<edgesSize;i++){
        int left=edges[i][0],right=edges[i][1],len=edges[i][2];
        map[left][length[left]][0]=right;  map[left][length[left]++][1]=len; 
        map[right][length[right]][0]=left;  map[right][length[right]++][1]=len;
    }
        max=0; dfs(0,0,0,0,maxTime);
        res=fmax(res,max);
    return res;
}




-----------------------------------------------------
3099
题目:
如果一个整数能够被其各个数位上的数字之和整除，则称之为 哈沙德数（Harshad number）。给你一个整数 x 。如果 x 是 哈沙德数 ，则返回 x 各个数位上的数字之和，否则，返回 -1 。

示例 1：
输入： x = 18
输出： 9
解释：
x 各个数位上的数字之和为 9 。18 能被 9 整除。因此 18 是哈沙德数，答案是 9 。
示例 2：
输入： x = 23
输出： -1
解释：
x 各个数位上的数字之和为 5 。23 不能被 5 整除。因此 23 不是哈沙德数，答案是 -1 。
解答：
go.c文件
int sumOfTheDigitsOfHarshadNumber(int x) {
    int s = 0;
    for (int v = x; v; v /= 10) {
        s += v % 10;
    }
    return x % s ? -1 : s;
}
-------------------------------------------------------
589
题目:
给定一个 n 叉树的根节点  root ，返回 其节点值的 前序遍历 。
n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。

示例 1：
输入：root = [1,null,3,2,4,null,5,6]
输出：[1,3,5,6,2,4]
示例 2：
输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出：[1,2,3,6,7,11,14,4,8,12,5,9,13,10]
解答：
go.c文件
#define MAXN 10000
static int buff[MAXN], next;

int* helper(struct Node *root);

int* preorder(struct Node *root, int *returnSize) {
    next = 0;
    helper(root);
    int *res = (int*)malloc(sizeof(int) * next);
    memcpy(res, buff, sizeof(int) * next);
    *returnSize = next;
    return res;
}

int* helper(struct Node *root) {
    if (!root) return NULL;
    buff[next++] = root->val;
    for (int i = 0; i < root->numChildren; ++i)
        helper(root->children[i]);
    return buff;
}
main.c文件:
#include "go.c"

首先，我们在 main 方法中构造了一个示例1中的 n 叉树：

代码执行过程讲解
为了详细讲解代码的执行过程，我们将从 main 方法开始，逐步分析每一步的操作。这里的核心任务是对 n 叉树进行前序遍历，并输出遍历结果。前序遍历的顺序是：根节点 -> 子节点1 -> 子节点1的子节点们 -> 子节点2 -> 子节点2的子节点们 -> ... 以此类推。

1. 构造树结构
首先，我们在 main 方法中构造了一个示例1中的 n 叉树：

createNode 函数
createNode 函数，它用于创建一个新的节点。
struct Node* createNode(int val, int numChildren) {         
    struct Node* node = (struct Node*)malloc(sizeof(struct Node));      //分配 sizeof(struct Node) 字节的内存，并将其指针转换为 struct Node* 类型，赋值给 node 变量。
    node->val = val;  
    node->numChildren = numChildren;  
    //将传入的 val 赋值给 node 的 val 属性。
    //将传入的 numChildren 赋值给 node 的 numChildren 属性。
    node->children = (struct Node**)malloc(sizeof(struct Node*) * numChildren);
    //分配 numChildren 个 struct Node* 类型的内存，用于存储子节点指针数组。
    return node;
}


struct Node {
    int val;
    int numChildren;
    struct Node** children;
};

// 构造示例1的树
struct Node* root = createNode(1, 3);   //此时也有了children[0],clildren[1],children[2]，需要储存信息
struct Node* child1 = createNode(3, 2);     //此时也有了children[0],clildren[1]，需要指向grandchild1和grandchild2,它们两无子节点
struct Node* child2 = createNode(2, 0);
struct Node* child3 = createNode(4, 0);
struct Node* grandchild1 = createNode(5, 0);
struct Node* grandchild2 = createNode(6, 0);

//子1节点绑定
root->children[0] = child1;
root->children[1] = child2;
root->children[2] = child3;
//子2节点绑定
child1->children[0] = grandchild1;
child1->children[1] = grandchild2;


root (0x1000)
+-----------------------+
| val = 1               |
| numChildren = 3       |
| children = 0x2000     |
+-----------------------+

children (0x2000)
+--------------------------+
| struct Node* children[3] |
|--------------------------|
| 0x3000                   |  --> child1
| 0x4000                   |  --> child2
| 0x5000                   |  --> child3
+--------------------------+

child1 (0x3000)
+-----------------------+
| val = 3               |
| numChildren = 2       |
| children = 0x6000     |
+-----------------------+

children of child1 (0x6000)
+--------------------------+
| struct Node* children[2] |
|--------------------------|
| 0x7000                   |  --> grandchild1
| 0x8000                   |  --> grandchild2
+--------------------------+

grandchild1 (0x7000)
+-----------------------+
| val = 5               |
| numChildren = 0       |
| children = NULL       |
+-----------------------+

grandchild2 (0x8000)
+-----------------------+
| val = 6               |
| numChildren = 0       |
| children = NULL       |
+-----------------------+

child2 (0x4000)
+-----------------------+
| val = 2               |
| numChildren = 0       |
| children = NULL       |
+-----------------------+

child3 (0x5000)
+-----------------------+
| val = 4               |
| numChildren = 0       |
| children = NULL       |
+-----------------------+

        1
       /|\
      3 2 4
     / \
    5   6


2. 调用前序遍历函数
接下来，我们调用 preorder 函数来进行前序遍历：
int returnSize;
int* result = preorder(root, &returnSize);

3. preorder 函数
preorder 函数调用了辅助函数 helper 来进行实际的遍历：
int* preorder(struct Node *root, int *returnSize) {
    next = 0;
    //初始化全局变量 next 为 0。next 用于记录遍历的节点数量。
    helper(root);
    //调用辅助函数 helper 进行前序遍历，将节点值存入 buff 数组。
    int *res = (int*)malloc(sizeof(int) * next);
    //运行完helpr后，分配 next 个 int 类型的内存，用于存储最终结果。
    memcpy(res, buff, sizeof(int) * next);
    //将 buff 数组中的内容复制到 res 数组。
    *returnSize = next;
    return res;
}

4. helper 函数
helper 函数递归地遍历每个节点：
int* helper(struct Node *root) {
    if (!root) return NULL;
    buff[next++] = root->val;
    for (int i = 0; i < root->numChildren; ++i)
        helper(root->children[i]);
    return buff;
}

5.执行过程图示
以下是 helper 函数的执行过程图示：
int* helper(struct Node *root) {
    if (!root) return NULL;
    //检查节点是否为空
    buff[next++] = root->val;
    //存储节点值,next++先执行再++
    for (int i = 0; i < root->numChildren; ++i)
    //这里i++与++i一样，然而，++i 更高效一些，因为它直接增加并返回增加后的值，而 i++ 则需要创建一个临时变量保存原始值，再增加后返回原始值。
        helper(root->children[i]);
        //root->children[i] 是指 root 节点的第 i 个子节点
        //递归遍历子节点，绝对不为NULL，因为有numChildren限制则return NULL
        //numChildren 是一个节点的子节点数量。循环次数是 numChildren，因为我们需要遍历每个子节点。
    return buff;
}
-----------------------------------------------
225
题目:
请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。
实现 MyStack 类：
void push(int x) 将元素 x 压入栈顶。
int pop() 移除并返回栈顶元素。
int top() 返回栈顶元素。
boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。
 
注意：
你只能使用队列的标准操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。
你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。

示例：
输入：
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 2, 2, false]
解释：
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // 返回 2
myStack.pop(); // 返回 2
myStack.empty(); // 返回 False
解答：
go.c文件

#define TAK_LEN 101

typedef struct {
    int *head;
    int *tail;
} MyStack;


MyStack* myStackCreate() {
    MyStack *obj = malloc(sizeof(MyStack));
    obj->head = malloc(sizeof(int) * TAK_LEN);
    obj->tail = obj->head;
    return obj;
}

void myStackPush(MyStack* obj, int x) {
    if (obj->tail == obj->head + TAK_LEN - 1)
        return;
    
    obj->tail++;
    *(obj->tail) = x;
}

int myStackPop(MyStack* obj) {
    int tmp;
    if (obj->tail == obj->head)
        return 0;

    tmp = *(obj->tail);
    obj->tail--;
    return tmp;
}

int myStackTop(MyStack* obj) {
    return *(obj->tail);
}

bool myStackEmpty(MyStack* obj) {
    if (obj->head == obj->tail)
        return true;
    
    return false;
}

void myStackFree(MyStack* obj) {
    free(obj->head);
    free(obj);
}

/**
 * Your MyStack struct will be instantiated and called as such:
 * MyStack* obj = myStackCreate();
 * myStackPush(obj, x);
 
 * int param_2 = myStackPop(obj);
 
 * int param_3 = myStackTop(obj);
 
 * bool param_4 = myStackEmpty(obj);
 
 * myStackFree(obj);
*/
main.c文件
int main() {
    // 创建一个栈实例
    MyStack* myStack = myStackCreate();

    // 执行操作
    myStackPush(myStack, 1);
    myStackPush(myStack, 2);

    int topElement = myStackTop(myStack); // 获取栈顶元素
    printf("Top element: %d\n", topElement); // 应输出 2

    int poppedElement = myStackPop(myStack); // 弹出栈顶元素
    printf("Popped element: %d\n", poppedElement); // 应输出 2

    bool isEmpty = myStackEmpty(myStack); // 检查栈是否为空
    printf("Is stack empty? %s\n", isEmpty ? "true" : "false"); // 应输出 false

    // 释放栈
    myStackFree(myStack);

    return 0;
}
head：指向栈的起始位置。实际上，它总是指向固定的位置（即栈底），用于标识栈的开始。
tail：指向栈的当前顶端位置。随着栈的操作（如压入和弹出元素），这个指针会动态变化，标识当前栈的顶端。


压入元素 1
执行 push(1) 操作：
void myStackPush(myStack* obj, int x) {
    if (obj->tail == TAK_LEN - 1) {
        return;  // 防止栈溢出
    }
    obj->tail++;  // 移动 tail 指针
    arr[obj->tail] = x;  // 将新元素存储在新的 tail 位置
}
此时，tail 向前移动一个位置，arr[1] 存储元素 1：
myStack:
    head: 0 -> [ ] [1] [ ] [ ] ... [ ]
             tail: 1
压入元素 2
执行 push(2) 操作：
void myStackPush(myStack* obj, int x) {
    if (obj->tail == TAK_LEN - 1) {
        return;  // 防止栈溢出
    }
    obj->tail++;  // 移动 tail 指针
    arr[obj->tail] = x;  // 将新元素存储在新的 tail 位置
}
此时，tail 向前移动一个位置，arr[2] 存储元素 2：
myStack:
    head: 0 -> [ ] [1] [2] [ ] ... [ ]
                  tail: 2

弹出元素 2
执行 pop 操作：
int myStackPop(myStack* obj) {
    if (obj->tail == obj->head) {
        return 0;  // 如果栈为空，则返回 0（或其他错误码）
    }
    int tmp = arr[obj->tail];  // 获取当前 tail 位置的元素
    obj->tail--;  // 移动 tail 指针
    return tmp;  // 返回弹出的元素
}
此时，tail 向后移动一个位置，栈顶元素 2 被弹出：
myStack:
    head: 0 -> [ ] [1] [ ] [ ] ... [ ]
             tail: 1
为什么隔一个第一位的arr[0]不填？
为了arr[obj->tail]指的就是第tail位

获取栈顶元素
执行 top 操作：
int myStackTop(myStack* obj) {
    return arr[obj->tail];  // 返回当前 tail 位置的元素
}
返回当前 tail 位置的元素，即 1

检查栈是否为空
执行 empty 操作：
bool myStackEmpty(myStack* obj) {
    return obj->head == obj->tail;  // 如果 head 和 tail 指向同一位置，则栈为空
}
此时，head 和 tail 不相同，因此返回 false。

释放栈
执行 free 操作：
void myStackFree(myStack* obj) {
    free(obj);
}
----------------------------------------------------------
232
题目:
请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：
实现 MyQueue 类：
void push(int x) 将元素 x 推到队列的末尾
int pop() 从队列的开头移除并返回元素
int peek() 返回队列开头的元素
boolean empty() 如果队列为空，返回 true ；否则，返回 false
说明：
你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

示例 1：
输入：
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 1, 1, false]
解释：
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
解答：
go.c文件
typedef struct {
    int* stk;
    int stkSize;
    int stkCapacity;
} Stack;

Stack* stackCreate(int cpacity) {
    Stack* ret = malloc(sizeof(Stack));
    ret->stk = malloc(sizeof(int) * cpacity);
    ret->stkSize = 0;
    ret->stkCapacity = cpacity;
    return ret;
}

void stackPush(Stack* obj, int x) {
    obj->stk[obj->stkSize++] = x;
}

void stackPop(Stack* obj) {
    obj->stkSize--;
}

int stackTop(Stack* obj) {
    return obj->stk[obj->stkSize - 1];
}

bool stackEmpty(Stack* obj) {
    return obj->stkSize == 0;
}

void stackFree(Stack* obj) {
    free(obj->stk);
}

typedef struct {
    Stack* inStack;
    Stack* outStack;
} MyQueue;

MyQueue* myQueueCreate() {
    MyQueue* ret = malloc(sizeof(MyQueue));
    ret->inStack = stackCreate(100);
    ret->outStack = stackCreate(100);
    return ret;
}

void in2out(MyQueue* obj) {
    while (!stackEmpty(obj->inStack)) {
        stackPush(obj->outStack, stackTop(obj->inStack));
        stackPop(obj->inStack);
    }
}

void myQueuePush(MyQueue* obj, int x) {
    stackPush(obj->inStack, x);
}

int myQueuePop(MyQueue* obj) {
    if (stackEmpty(obj->outStack)) {
        in2out(obj);
    }
    int x = stackTop(obj->outStack);
    stackPop(obj->outStack);
    return x;
}

int myQueuePeek(MyQueue* obj) {
    if (stackEmpty(obj->outStack)) {
        in2out(obj);
    }
    return stackTop(obj->outStack);
}

bool myQueueEmpty(MyQueue* obj) {
    return stackEmpty(obj->inStack) && stackEmpty(obj->outStack);
}

void myQueueFree(MyQueue* obj) {
    stackFree(obj->inStack);
    stackFree(obj->outStack);
}

图形表示：
初始状态：
myQueue:
    inStack:  []
    outStack: []
push(1) 后：
myQueue:
    inStack:  [1]
    outStack: []
push(2) 后：
myQueue:
    inStack:  [1, 2]
    outStack: []
peek() 触发 in2out 后：
myQueue:
    inStack:  []
    outStack: [2, 1]
pop() 弹出 1 后：
myQueue:
    inStack:  []
    outStack: [2]
算法介绍
这个解决方案使用了两个栈来模拟队列操作，以下是主要思想：
Push 操作：总是将新元素压入 inStack。
Pop 和 Peek 操作：当 outStack 为空时，将 inStack 中的所有元素转移到 outStack，这样 outStack 的栈顶元素就是队列的队首元素。
Empty 操作：检查 inStack 和 outStack 是否都为空。
这种方法利用了栈的后入先出（LIFO）特性，通过两个栈反转元素顺序，从而实现了队列的先进先出（FIFO）特性。这种方法的时间复杂度为 O(1) 对于 push 操作，以及摊销的 O(1) 对于 pop 和 peek 操作。
---------------------------------------------------
2129
题目:
给你一个字符串 title ，它由单个空格连接一个或多个单词组成，每个单词都只包含英文字母。请你按以下规则将每个单词的首字母 大写 ：
如果单词的长度为 1 或者 2 ，所有字母变成小写。
否则，将单词首字母大写，剩余字母变成小写。
请你返回 大写后 的 title 。

示例 1：
输入：title = "capiTalIze tHe titLe"
输出："Capitalize The Title"
解释：
由于所有单词的长度都至少为 3 ，将每个单词首字母大写，剩余字母变为小写。
示例 2：
输入：title = "First leTTeR of EACH Word"
输出："First Letter of Each Word"
解释：
单词 "of" 长度为 2 ，所以它保持完全小写。
其他单词长度都至少为 3 ，所以其他单词首字母大写，剩余字母小写。
示例 3：
输入：title = "i lOve leetcode"
输出："i Love Leetcode"
解释：
单词 "i" 长度为 1 ，所以它保留小写。
其他单词长度都至少为 3 ，所以其他单词首字母大写，剩余字母小写。
解答：
go.c文件
char * capitalizeTitle(char * title){
    int len = strlen(title);
    int j = 0;
    for (int i = 0; i <= len; i++) {
        if (title[i] == ' ' || title[i] == '\0') {
            if (i - j > 2) {
                title[j] = toupper(title[j]); /* 转为大写 */
            }
            j = i + 1; /* 更新起始位置 */
        } else {
            title[i] = tolower(title[i]); /* 其余转为小写 */
        }
    }
    return title;
}
------------------------------------------------------------------
303
题目:
给定一个整数数组  nums，处理以下类型的多个查询:
计算索引 left 和 right （包含 left 和 right）之间的 nums 元素的 和 ，其中 left <= right
实现 NumArray 类：
NumArray(int[] nums) 使用数组 nums 初始化对象
int sumRange(int i, int j) 返回数组 nums 中索引 left 和 right 之间的元素的 总和 ，包含 left 和 right 两点（也就是 nums[left] + nums[left + 1] + ... + nums[right] )
 
示例 1：
输入：
["NumArray", "sumRange", "sumRange", "sumRange"]
[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]
输出：
[null, 1, -1, -3]
解释：
NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);
numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)
numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) 
numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))
解答：
go.c文件
typedef struct {
    int* presum;
    int size;
} NumArray;
NumArray* numArrayCreate(int* nums, int numsSize) {
    NumArray* obj=(NumArray*)malloc(sizeof(NumArray));
    obj->presum=(int*)malloc((numsSize+1)*sizeof(int));
    obj->size=numsSize+1;
    obj->presum[0]=0;
    for(int i=1;i<obj->size;i++)
    {
        obj->presum[i]=obj->presum[i-1]+nums[i-1];
    }
    return obj;
}
int numArraySumRange(NumArray* obj, int left, int right) {
    return obj->presum[right+1]-obj->presum[left];
}
void numArrayFree(NumArray* obj) {
    free(obj->presum);
    free(obj);
}
/**
 * Your NumArray struct will be instantiated and called as such:
 * NumArray* obj = numArrayCreate(nums, numsSize);
 * int param_1 = numArraySumRange(obj, left, right);
 
 * numArrayFree(obj);
*/

1. 创建 NumArray 对象
调用 numArrayCreate 函数：
执行步骤如下：
初始化 presum 数组，大小为 numsSize + 1，初始值为 0。
计算前缀和数组 presum，其中 presum[i] 表示从 nums[0] 到 nums[i-1] 的累积和。

对于输入数组 nums = {-2, 0, 3, -5, 2, -1}，计算结果为：
presum = [0, -2, -2, 1, -4, -2, -3]

2. 调用 sumRange 函数
通过调用 numArraySumRange 函数计算区间和：
执行步骤如下：
对于 sumRange(0, 2)：   //index:0,1,2三个数的和
presum[3] - presum[0] = 1 - 0 = 1   //presum[0]是初始化的0，后面presum[1]才对应的nums[0]
返回结果为 1。

对于 sumRange(2, 5)：
presum[6] - presum[2] = -3 - (-2) = -1
返回结果为 -1。

对于 sumRange(0, 5)：
presum[6] - presum[0] = -3 - 0 = -3
返回结果为 -3。

3. 释放内存
调用 numArrayFree 函数释放内存

算法介绍
这个解决方案采用了前缀和（Prefix Sum）算法：
前缀和数组：在初始化时，计算出前缀和数组 presum，其中 presum[i] 表示从 nums[0] 到 nums[i-1] 的累积和。
快速查询区间和：通过计算 presum[right + 1] - presum[left]，可以快速得到区间 [left, right] 的和。
------------------------------------------
2908
题目:
给你一个下标从 0 开始的整数数组 nums 。
如果下标三元组 (i, j, k) 满足下述全部条件，则认为它是一个 山形三元组 ：
i < j < k
nums[i] < nums[j] 且 nums[k] < nums[j]
请你找出 nums 中 元素和最小 的山形三元组，并返回其 元素和 。如果不存在满足条件的三元组，返回 -1 。

示例 1：
输入：nums = [8,6,1,5,3]
输出：9
解释：三元组 (2, 3, 4) 是一个元素和等于 9 的山形三元组，因为： 
- 2 < 3 < 4
- nums[2] < nums[3] 且 nums[4] < nums[3]
这个三元组的元素和等于 nums[2] + nums[3] + nums[4] = 9 。可以证明不存在元素和小于 9 的山形三元组。
示例 2：
输入：nums = [5,4,8,7,10,2]
输出：13
解释：三元组 (1, 3, 5) 是一个元素和等于 13 的山形三元组，因为： 
- 1 < 3 < 5 
- nums[1] < nums[3] 且 nums[5] < nums[3]
这个三元组的元素和等于 nums[1] + nums[3] + nums[5] = 13 。可以证明不存在元素和小于 13 的山形三元组。
示例 3：
输入：nums = [6,5,4,3,4,5]
输出：-1
解释：可以证明 nums 中不存在山形三元组。
解答：
go.c文件
#include <limits.h>
int minimumSum(int* nums, int numsSize) {
    if (numsSize < 3) return -1;

    int leftMin[numsSize], rightMin[numsSize];
    leftMin[0] = INT_MAX;
    rightMin[numsSize - 1] = INT_MAX;

    // Fill leftMin array
    for (int i = 1; i < numsSize; i++) {
        leftMin[i] = (nums[i - 1] < leftMin[i - 1]) ? nums[i - 1] : leftMin[i - 1];
    }

    // Fill rightMin array
    for (int i = numsSize - 2; i >= 0; i--) {
        rightMin[i] = (nums[i + 1] < rightMin[i + 1]) ? nums[i + 1] : rightMin[i + 1];
    }

    int minSum = INT_MAX;
    int found = 0;

    // Find the minimum sum of mountain triplets
    for (int j = 1; j < numsSize - 1; j++) {
        if (nums[j] > leftMin[j] && nums[j] > rightMin[j]) {
            int currentSum = nums[j] + leftMin[j] + rightMin[j];
            if (currentSum < minSum) {
                minSum = currentSum;
                found = 1;
            }
        }
    }

    return found ? minSum : -1;
}
main.c文件:
int main() {
    int nums1[] = {8, 6, 1, 5, 3};
    int numsSize1 = sizeof(nums1) / sizeof(nums1[0]);
    printf("Minimum sum for nums1: %d\n", minimumSum(nums1, numsSize1)); // 应输出 9

    int nums2[] = {5, 4, 8, 7, 10, 2};
    int numsSize2 = sizeof(nums2) / sizeof(nums2[0]);
    printf("Minimum sum for nums2: %d\n", minimumSum(nums2, numsSize2)); // 应输出 13

    int nums3[] = {6, 5, 4, 3, 4, 5};
    int numsSize3 = sizeof(nums3) / sizeof(nums3[0]);
    printf("Minimum sum for nums3: %d\n", minimumSum(nums3, numsSize3)); // 应输出 -1

    return 0;
}

main 函数中，定义了数组 nums1 和其大小 numsSize1。
调用 minimumSum(nums1, numsSize1)。

在 minimumSum 函数中
检查 numsSize 是否小于3，若小于3，直接返回 -1。此示例 numsSize = 5，不小于3，继续执行。
初始化 leftMin 和 rightMin 数组
leftMin 初始化为 [INT_MAX, INT_MAX, INT_MAX, INT_MAX, INT_MAX]
rightMin 初始化为 [INT_MAX, INT_MAX, INT_MAX, INT_MAX, INT_MAX]
leftMin[0] = INT_MAX
rightMin[4] = INT_MAX （rightMin 的最后一个元素）
Initial arrays:
leftMin  = [INT_MAX,  ,  ,  ,  ]
rightMin = [ ,  ,  ,  , INT_MAX]

填充 leftMin 数组
遍历 nums 从第二个元素到最后一个元素，逐步填充 leftMin 数组：
i = 1：leftMin[1] = min(INT_MAX, 8) = 8
i = 2：leftMin[2] = min(8, 6) = 6
i = 3：leftMin[3] = min(6, 1) = 1
i = 4：leftMin[4] = min(1, 5) = 1
Filled leftMin array:
leftMin  = [INT_MAX, 8, 6, 1, 1]

填充 rightMin 数组
遍历 nums 从倒数第二个元素到第一个元素，逐步填充 rightMin 数组：
i = 3：rightMin[3] = min(INT_MAX, 3) = 3
i = 2：rightMin[2] = min(3, 5) = 3
i = 1：rightMin[1] = min(3, 1) = 1
i = 0：rightMin[0] = min(1, 6) = 1
Filled rightMin array:
rightMin = [1, 1, 3, 3, INT_MAX]
rightMin 和 leftMin 是辅助数组，用于存储数组 nums 在不同位置上的前缀和后缀最小值。这两个数组用于帮助快速查找每个位置的左侧和右侧的最小值，从而有效地确定是否存在符合条件的山形三元组。
leftMin: leftMin[i] 存储的是从数组 nums 开始到位置 i-1 之间的最小值。也就是说，对于每个位置 i，leftMin[i] 表示在 nums 数组中位置 i 左侧的最小值。
rightMin: rightMin[i] 存储的是从数组 nums 的位置 i+1 到末尾之间的最小值。也就是说，对于每个位置 i，rightMin[i] 表示在 nums 数组中位置 i 右侧的最小值。

查找山形三元组
遍历 nums 从第二个元素到倒数第二个元素，检查是否满足山形三元组条件，并计算其和：
j = 1：不满足 nums[1] > leftMin[1] && nums[1] > rightMin[1]。
j = 2：不满足 nums[2] > leftMin[2] && nums[2] > rightMin[2]。
j = 3：满足 nums[3] > leftMin[3] && nums[3] > rightMin[3]，计算和 nums[3] + leftMin[3] + rightMin[3] = 5 + 1 + 3 = 9。更新 minSum 为 9。
Mountain triplet found at j = 3:
nums[j] = 5, leftMin[j] = 1, rightMin[j] = 3
Minimum sum: 9

返回结果
检查 found 是否为 1，是则返回 minSum，否则返回 -1。
最终返回结果为 9。
------------------------------------------------